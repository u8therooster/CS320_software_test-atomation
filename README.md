# CS320_software_test-atomation
During the development of the mobile application's back-end services for Grand Strand Systems, I applied a systematic unit testing approach using JUnit 5 to ensure each service met the customer’s requirements. The project involved the creation of three primary service modules: ContactService, TaskService, and AppointmentService. Each module was tested using tailored unit tests to validate correct behavior, input validation, and robustness.
For the ContactService, I verified the functionality to add, update, and delete contact objects. Each test ensured that the contactId was immutable and that all fields, such as firstName, lastName, phone, and address, met required length and null constraints. My approach for this module aligned with requirements like disallowing null or overly long inputs. For instance, in ContactTest.java, the test method testAddressTooLong() asserts that a long string throws an exception, satisfying the requirement that the address must be under 30 characters.
Similarly, in the TaskService, I implemented unit tests that validated the taskId, name, and description fields against null and length constraints. The service logic was tested to handle duplicate task IDs and invalid updates. The method testSetNameInvalid() within TaskTest.java is an example where I ensured the name does not exceed 20 characters, aligning directly with the project requirement.
The AppointmentService required careful handling of Date objects. I tested to ensure that appointments could not be scheduled in the past, using Date.before(new Date()) logic in the Appointment.java constructor. This was validated through testAppointmentDateInPast() in AppointmentTest.java. My tests ensured the immutability of the appointmentId and length constraints on the description.
The overall quality of my tests is evidenced by the thoroughness of validation. I tested all positive and negative paths to achieve over 80% code coverage per file. JUnit test effectiveness was confirmed using Eclipse’s code coverage tools and by asserting that all logical branches were executed during testing.
In terms of efficiency and technical soundness, I kept each test concise and single-purpose. For instance, in AppointmentTest.java, each field is tested in isolation (e.g., testAppointmentIdNull(), testAppointmentDescriptionTooLong()), making it easy to pinpoint failures and validate individual constraints. This modularity also enhances test maintainability.
Testing Techniques
I employed black-box testing and boundary value analysis throughout this project. These techniques focus on testing inputs and outputs without requiring internal knowledge of the system. Each unit test focused on the boundaries (e.g., maximum allowed characters) and invalid inputs. For example, testContactPhoneInvalidLength() demonstrates boundary testing for exactly 10 digits.
Techniques not used in this project include white-box testing (e.g., branch or path coverage) and exploratory testing, which are more suited for complex applications with logic-heavy services or a UI. White-box testing could be more applicable when testing conditional logic or algorithms, while exploratory testing would help uncover unexpected edge cases in interactive software.
Mindset
Throughout this project, I adopted a cautious and detail-oriented mindset. As a software tester, I assumed that every input field could be a potential source of bugs or violations. For instance, I anticipated the possibility of developers forgetting to handle null values or maximum length constraints and explicitly wrote tests to catch those.
To reduce bias while reviewing code I authored, I separated the development and testing phases. I reviewed the requirements carefully and wrote tests before revisiting the implementation to see if those tests would fail as expected. This "test-first" mindset helped me simulate the experience of an independent tester.
Bias could be a concern when developers test their own code because of overconfidence or assumptions that their logic is flawless. For example, I originally believed a past Date test was unnecessary until I realized it was critical to enforce the business rule about future appointments.
Discipline and quality commitment were essential in this project. Cutting corners would have led to missed edge cases or failing to catch critical bugs. For example, skipping null checks on the setAddress() method in Contact.java could have introduced instability in future releases.
To avoid technical debt, I plan to stick to writing complete and modular unit tests during the development cycle. I will also document test logic clearly and review tests after each feature iteration. This practice ensures future maintainability and helps prevent regression.
How can I ensure that my code, program, or software is functional and secure?
I ensure functionality and security by using rigorous unit testing to validate all input conditions, constraints, and expected behaviors. By proactively checking nulls, length limits, and invalid formats, I prevent vulnerabilities such as buffer overflows or null pointer exceptions. I also avoid mutable critical fields (like IDs) and ensure data integrity with proper exception handling.
How do I interpret user needs and incorporate them into a program?
I start by reading the functional requirements thoroughly and then translating each requirement into a set of testable behaviors. For instance, when the customer specified that appointment dates must not be in the past, I directly encoded this rule into the constructor and wrote a corresponding test case (testAppointmentDateInPast) to confirm enforcement. I also incorporate feedback to improve coverage, like adding null and length validation tests.
How do I approach designing software?
I begin by identifying key data models (e.g., Contact, Task, Appointment), defining their responsibilities, and creating services to manage their lifecycle. I ensure all classes are cohesive, each method is single-purpose, and responsibilities are clearly separated. I follow a test-driven development mindset, writing unit tests in parallel with or before the implementation, which leads to more robust, maintainable, and well-documented code.
